#!/bin/bash

# %%SCRIPT_NAME%%
#
# Description: bash template script
# Author: kb9zzw <kb9zzw@gmail.com>

# runtime options
set -e -o pipefail

# global default variables
arg_a="default a value"
arg_b="default b value"

# call on_exit on EXIT
trap "on_exit" EXIT

# script log level
LOG_LEVEL=${LOG_LEVEL:-INFO}

# supported log levels
declare -A log_levels
log_levels['DEBUG']=0
log_levels['INFO']=1
log_levels['NOTICE']=2
log_levels['WARNING']=3
log_levels['ERROR']=4
log_levels['CRITICAL']=5
log_levels['ALERT']=6
log_levels['EMERGENCY']=7

# logging function
log() {
  local msg=$1
  local severity=${2:-"INFO"}

  if [[ ${log_levels[$severity]} -ge ${log_levels[$LOG_LEVEL]} ]]
  then
    echo "[$(date --iso=seconds)] $(basename $0) : $severity: $msg" >&2
  fi
}

# log error an exit
error_exit() {
  log "error_exit called" DEBUG
  local msg=${1:-"an error occurred"}
  local code=${2:-1}
  log "$msg" ERROR 
  exit $code
}

# always called on exit
on_exit() {
  log "on_exit called" DEBUG
}

usage() {
  log "usage called" DEBUG
  cat<<EOF
usage: $(basename $0) [args]

arguments:
  -h          Print usage and exit
  -a [arg_a]  Argument A (default: $arg_a)
  -b [arg_b]  Argument B (default: $arg_b)
EOF
}

# process arguments
parse_args() {
  log "parse_args called" DEBUG
  local optstring=":ha:b:"

  while getopts ${optstring} arg; do
    case ${arg} in
      h)
        usage
        exit 0
        ;;
      a)
        arg_a=${OPTARG}
        ;;
      b)
        arg_b=${OPTARG}
        ;;
      :)
        error_exit "must supply an argument to -${OPTARG}" 1
        ;;
      ?)
        usage
        error_exit "invalid argument: -${OPTARG}" 2
        ;;
    esac
  done
}

# main script
main() {
  log "main called" DEBUG

  # parse arguments
  parse_args "$@"

  # main script
  log "Argument A: $arg_a" INFO
  sleep 5
  log "Argument B: $arg_b" INFO
}

main "$@"
